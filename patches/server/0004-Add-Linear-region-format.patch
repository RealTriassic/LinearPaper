From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Triassic <techbyteofficial9@gmail.com>
Date: Sat, 23 Sep 2023 01:18:14 +0300
Subject: [PATCH] Add Linear region format


diff --git a/build.gradle.kts b/build.gradle.kts
index dd44de960db4faf8c71430c28b501fd2156ba4c3..ec8a3f139d984dc461c5d214bd7d58e6ebf071c2 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -29,6 +29,10 @@ dependencies {
     alsoShade(log4jPlugins.output)
     implementation("io.netty:netty-codec-haproxy:4.1.97.Final") // Paper - Add support for proxy protocol
     // Paper end
+    // LinearPaper start
+    implementation("com.github.luben:zstd-jni:1.5.6-3")
+    implementation("org.lz4:lz4-java:1.8.0")
+    // LinearPaper end
     implementation("org.apache.logging.log4j:log4j-iostreams:2.22.1") // Paper - remove exclusion
     implementation("org.ow2.asm:asm-commons:9.7")
     implementation("org.spongepowered:configurate-yaml:4.2.0-SNAPSHOT") // Paper - config files
diff --git a/src/main/java/io/papermc/paper/world/ThreadedWorldUpgrader.java b/src/main/java/io/papermc/paper/world/ThreadedWorldUpgrader.java
index 7f6d1ccd147e5593412567bb2934ce5662da7ef0..6ca14990cb624c67b0061730c2877b1684c872f1 100644
--- a/src/main/java/io/papermc/paper/world/ThreadedWorldUpgrader.java
+++ b/src/main/java/io/papermc/paper/world/ThreadedWorldUpgrader.java
@@ -9,7 +9,6 @@ import net.minecraft.nbt.CompoundTag;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.util.worldupdate.WorldUpgrader;
 import net.minecraft.world.level.ChunkPos;
-import net.minecraft.world.level.Level;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.chunk.storage.ChunkStorage;
 import net.minecraft.world.level.chunk.storage.RegionFileStorage;
@@ -19,6 +18,7 @@ import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelStorageSource;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
 import java.io.File;
 import java.io.IOException;
 import java.text.DecimalFormat;
@@ -97,8 +97,10 @@ public class ThreadedWorldUpgrader {
             "region"
         );
 
+        org.stupidcraft.linearpaper.region.RegionFileFormat formatName = ((org.bukkit.craftbukkit.CraftWorld) Bukkit.getWorld(worldName)).getHandle().paperConfig().regionFormat.regionFormatName;
+        int linearCompression = ((org.bukkit.craftbukkit.CraftWorld) Bukkit.getWorld(worldName)).getHandle().paperConfig().regionFormat.regionFormatLinearCompressionLevel;
         final WorldInfo info = new WorldInfo(() -> worldPersistentData,
-                new ChunkStorage(storageInfo, regionFolder.toPath(), this.dataFixer, false), this.removeCaches, this.dimensionType, this.generatorKey);
+                new ChunkStorage(formatName, linearCompression, storageInfo, regionFolder.toPath(), this.dataFixer, false), this.removeCaches, this.dimensionType, this.generatorKey);
 
         long expectedChunks = (long)regionFiles.length * (32L * 32L);
 
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 228c1d184d93ee2f054f48f74e3bf7d85b773d08..b7ddb5e55ed788a62c6631ab85bf2f7b4145004d 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -250,7 +250,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Paper end - optimise chunk tick iteration
 
     public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureTemplateManager structureTemplateManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int viewDistance, boolean dsync) {
-        super(new RegionStorageInfo(session.getLevelId(), world.dimension(), "chunk"), session.getDimensionPath(world.dimension()).resolve("region"), dataFixer, dsync);
+        super(world.getLevel().paperConfig().regionFormat.regionFormatName, world.getLevel().paperConfig().regionFormat.regionFormatLinearCompressionLevel, new RegionStorageInfo(session.getLevelId(), world.dimension(), "chunk"), session.getDimensionPath(world.dimension()).resolve("region"), dataFixer, dsync);
         // Paper - rewrite chunk system
         this.tickingGenerated = new AtomicInteger();
         this.playerMap = new PlayerMap();
@@ -293,7 +293,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         this.lightEngine = new ThreadedLevelLightEngine(chunkProvider, this, this.level.dimensionType().hasSkyLight(), null, null); // Paper - rewrite chunk system
         this.distanceManager = new ChunkMap.ChunkDistanceManager(executor, mainThreadExecutor);
         this.overworldDataStorage = persistentStateManagerFactory;
-        this.poiManager = new PoiManager(new RegionStorageInfo(session.getLevelId(), world.dimension(), "poi"), path.resolve("poi"), dataFixer, dsync, iregistrycustom, world);
+        this.poiManager = new PoiManager(world.getLevel().paperConfig().regionFormat.regionFormatName, world.getLevel().paperConfig().regionFormat.regionFormatLinearCompressionLevel, new RegionStorageInfo(session.getLevelId(), world.dimension(), "poi"), path.resolve("poi"), dataFixer, dsync, iregistrycustom, world);
         this.setServerViewDistance(viewDistance);
         this.worldGenContext = new WorldGenContext(world, chunkGenerator, structureTemplateManager, this.lightEngine);
         // Paper start
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index ca56a0b596976448da6bb2a0e82b3d5cd4133e12..a73bd9b25e12961903be1d12fd3761768d2697bf 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -423,8 +423,8 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     private static final class EntityRegionFileStorage extends net.minecraft.world.level.chunk.storage.RegionFileStorage {
 
-        public EntityRegionFileStorage(RegionStorageInfo storageKey, Path directory, boolean dsync) {
-            super(storageKey, directory, dsync);
+        public EntityRegionFileStorage(org.stupidcraft.linearpaper.region.RegionFileFormat format, int linearCompression, RegionStorageInfo storageKey, Path directory, boolean dsync) {
+            super(format, linearCompression, storageKey, directory, dsync);
         }
 
         protected void write(ChunkPos pos, net.minecraft.nbt.CompoundTag nbt) throws IOException {
@@ -734,7 +734,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         // CraftBukkit end
         boolean flag2 = minecraftserver.forceSynchronousWrites();
         DataFixer datafixer = minecraftserver.getFixerUpper();
-        this.entityStorage = new EntityRegionFileStorage(new RegionStorageInfo(convertable_conversionsession.getLevelId(), resourcekey, "entities"), convertable_conversionsession.getDimensionPath(resourcekey).resolve("entities"), flag2); // Paper - rewrite chunk system
+        this.entityStorage = new EntityRegionFileStorage(this.getLevel().paperConfig().regionFormat.regionFormatName, this.getLevel().paperConfig().regionFormat.regionFormatLinearCompressionLevel, new RegionStorageInfo(convertable_conversionsession.getLevelId(), resourcekey, "entities"), convertable_conversionsession.getDimensionPath(resourcekey).resolve("entities"), flag2); // Paper - rewrite chunk system
 
         // this.entityManager = new PersistentEntitySectionManager<>(Entity.class, new ServerLevel.EntityCallbacks(), entitypersistentstorage, this.entitySliceManager); // Paper // Paper - rewrite chunk system
         StructureTemplateManager structuretemplatemanager = minecraftserver.getStructureManager();
diff --git a/src/main/java/net/minecraft/util/worldupdate/WorldUpgrader.java b/src/main/java/net/minecraft/util/worldupdate/WorldUpgrader.java
index 6c1faa9b5cf099029bcb122731e3e50e46a4abf0..a91f0228071272c3d9f21ae79921e4ecdddfa38c 100644
--- a/src/main/java/net/minecraft/util/worldupdate/WorldUpgrader.java
+++ b/src/main/java/net/minecraft/util/worldupdate/WorldUpgrader.java
@@ -76,7 +76,7 @@ public class WorldUpgrader {
     volatile int skipped;
     final Reference2FloatMap<ResourceKey<Level>> progressMap = Reference2FloatMaps.synchronize(new Reference2FloatOpenHashMap());
     volatile Component status = Component.translatable("optimizeWorld.stage.counting");
-    public static final Pattern REGEX = Pattern.compile("^r\\.(-?[0-9]+)\\.(-?[0-9]+)\\.mca$");
+    public static final Pattern REGEX = Pattern.compile("^r\\.(-?[0-9]+)\\.(-?[0-9]+)\\.(linear | mca)$"); // LinearPaper
     final DimensionDataStorage overworldDataStorage;
 
     public WorldUpgrader(LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, RegistryAccess dynamicRegistryManager, boolean eraseCache, boolean recreateRegionFiles) {
@@ -249,7 +249,10 @@ public class WorldUpgrader {
 
         @Override
         protected ChunkStorage createStorage(RegionStorageInfo key, Path worldDirectory) {
-            return (ChunkStorage) (WorldUpgrader.this.recreateRegionFiles ? new RecreatingChunkStorage(key.withTypeSuffix("source"), worldDirectory, key.withTypeSuffix("target"), WorldUpgrader.resolveRecreateDirectory(worldDirectory), WorldUpgrader.this.dataFixer, true) : new ChunkStorage(key, worldDirectory, WorldUpgrader.this.dataFixer, true));
+            String worldName = levelStorage.getLevelId();
+            org.stupidcraft.linearpaper.region.RegionFileFormat formatName = ((org.bukkit.craftbukkit.CraftWorld) org.bukkit.Bukkit.getWorld(worldName)).getHandle().paperConfig().regionFormat.regionFormatName;
+            int linearCompression = ((org.bukkit.craftbukkit.CraftWorld) org.bukkit.Bukkit.getWorld(worldName)).getHandle().paperConfig().regionFormat.regionFormatLinearCompressionLevel;
+            return (ChunkStorage) (WorldUpgrader.this.recreateRegionFiles ? new RecreatingChunkStorage(formatName, linearCompression, key.withTypeSuffix("source"), worldDirectory, key.withTypeSuffix("target"), WorldUpgrader.resolveRecreateDirectory(worldDirectory), WorldUpgrader.this.dataFixer, true) : new ChunkStorage(formatName, linearCompression, key, worldDirectory, WorldUpgrader.this.dataFixer, true));
         }
     }
 
@@ -261,7 +264,10 @@ public class WorldUpgrader {
 
         @Override
         protected SimpleRegionStorage createStorage(RegionStorageInfo key, Path worldDirectory) {
-            return (SimpleRegionStorage) (WorldUpgrader.this.recreateRegionFiles ? new RecreatingSimpleRegionStorage(key.withTypeSuffix("source"), worldDirectory, key.withTypeSuffix("target"), WorldUpgrader.resolveRecreateDirectory(worldDirectory), WorldUpgrader.this.dataFixer, true, this.dataFixType) : new SimpleRegionStorage(key, worldDirectory, WorldUpgrader.this.dataFixer, true, this.dataFixType));
+            String worldName = levelStorage.getLevelId();
+            org.stupidcraft.linearpaper.region.RegionFileFormat formatName = ((org.bukkit.craftbukkit.CraftWorld) org.bukkit.Bukkit.getWorld(worldName)).getHandle().paperConfig().regionFormat.regionFormatName;
+            int linearCompression = ((org.bukkit.craftbukkit.CraftWorld) org.bukkit.Bukkit.getWorld(worldName)).getHandle().paperConfig().regionFormat.regionFormatLinearCompressionLevel;
+            return (SimpleRegionStorage) (WorldUpgrader.this.recreateRegionFiles ? new RecreatingSimpleRegionStorage(formatName, linearCompression, key.withTypeSuffix("source"), worldDirectory, key.withTypeSuffix("target"), WorldUpgrader.resolveRecreateDirectory(worldDirectory), WorldUpgrader.this.dataFixer, true, this.dataFixType) : new SimpleRegionStorage(formatName, linearCompression, key, worldDirectory, WorldUpgrader.this.dataFixer, true, this.dataFixType));
         }
 
         protected boolean tryProcessOnePosition(SimpleRegionStorage storage, ChunkPos chunkPos, ResourceKey<Level> worldKey) {
@@ -406,7 +412,7 @@ public class WorldUpgrader {
 
         private static List<WorldUpgrader.FileToUpgrade> getAllChunkPositions(RegionStorageInfo key, Path regionDirectory) {
             File[] afile = regionDirectory.toFile().listFiles((file, s) -> {
-                return s.endsWith(".mca");
+                return s.endsWith(".mca") || s.endsWith(".linear"); // LinearPaper
             });
 
             if (afile == null) {
@@ -426,7 +432,7 @@ public class WorldUpgrader {
                         List<ChunkPos> list1 = Lists.newArrayList();
 
                         try {
-                            org.stupidcraft.linearpaper.region.AbstractRegionFile regionfile = org.stupidcraft.linearpaper.region.AbstractRegionFileFactory.getAbstractRegionFile(key, file.toPath(), regionDirectory, true); // LinearPaper
+                            org.stupidcraft.linearpaper.region.AbstractRegionFile regionfile = org.stupidcraft.linearpaper.region.AbstractRegionFileFactory.getAbstractRegionFile(1, key, file.toPath(), regionDirectory, true); // LinearPaper // TODO Set linear compression value.
 
                             try {
                                 for (int i1 = 0; i1 < 32; ++i1) {
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
index c6f193339fdcbcc938d4eafdcad0b112cf1698d5..78bd3f0846d46ca2f590ade955b86ab3c4ac74a7 100644
--- a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
@@ -59,15 +59,19 @@ public class PoiManager extends SectionStorage<PoiSection> {
     // Paper end - rewrite chunk system
 
     public PoiManager(
-        RegionStorageInfo storageKey, Path directory, DataFixer dataFixer, boolean dsync, RegistryAccess registryManager, LevelHeightAccessor world
+        org.stupidcraft.linearpaper.region.RegionFileFormat formatName, int linearCompression, RegionStorageInfo storageKey, Path directory, DataFixer dataFixer, boolean dsync, RegistryAccess registryManager, LevelHeightAccessor world
     ) {
         super(
+            // LinearPaper start
+            formatName,
+            linearCompression,
+            // LinearPaper end
             // Paper start
             storageKey,
             directory,
             dsync,
             // Paper end
-            new SimpleRegionStorage(storageKey, directory, dataFixer, dsync, DataFixTypes.POI_CHUNK),
+            new SimpleRegionStorage(formatName, linearCompression, storageKey, directory, dataFixer, dsync, DataFixTypes.POI_CHUNK),
             PoiSection::codec,
             PoiSection::new,
             registryManager,
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkStorage.java
index 7801fac96d728f951989fca36f6a4890a0638c36..979d1c962c7e8406a363de3060bbbc49d3a9c631 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkStorage.java
@@ -39,9 +39,9 @@ public class ChunkStorage implements AutoCloseable {
     @Nullable
     private volatile LegacyStructureDataHandler legacyStructureHandler;
 
-    public ChunkStorage(RegionStorageInfo storageKey, Path directory, DataFixer dataFixer, boolean dsync) {
+    public ChunkStorage(org.stupidcraft.linearpaper.region.RegionFileFormat format, int linearCompression, RegionStorageInfo storageKey, Path directory, DataFixer dataFixer, boolean dsync) {
         this.fixerUpper = dataFixer;
-        this.regionFileCache = new RegionFileStorage(storageKey, directory, dsync, true); // Paper - rewrite chunk system; async chunk IO & Attempt to recalculate regionfile header if it is corrupt
+        this.regionFileCache = new RegionFileStorage(format, linearCompression, storageKey, directory, dsync, true); // Paper - rewrite chunk system; async chunk IO & Attempt to recalculate regionfile header if it is corrupt
     }
 
     public boolean isOldChunkAround(ChunkPos chunkPos, int checkRadius) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/IOWorker.java b/src/main/java/net/minecraft/world/level/chunk/storage/IOWorker.java
index 5165683b6ba4921663a3d564b87b6561a0744e53..91ab62499aa6e7c52beb8bb8766b9901fae21d17 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/IOWorker.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/IOWorker.java
@@ -37,8 +37,8 @@ public class IOWorker implements ChunkScanAccess, AutoCloseable {
     private final Long2ObjectLinkedOpenHashMap<CompletableFuture<BitSet>> regionCacheForBlender = new Long2ObjectLinkedOpenHashMap<>();
     private static final int REGION_CACHE_SIZE = 1024;
 
-    protected IOWorker(RegionStorageInfo storageKey, Path directory, boolean dsync) {
-        this.storage = new RegionFileStorage(storageKey, directory, dsync);
+    protected IOWorker(org.stupidcraft.linearpaper.region.RegionFileFormat format, int linearCompression, RegionStorageInfo storageKey, Path directory, boolean dsync) {
+        this.storage = new RegionFileStorage(format, linearCompression, storageKey, directory, dsync);
         this.mailbox = new ProcessorMailbox<>(
             new StrictQueue.FixedPriorityQueue(IOWorker.Priority.values().length), Util.ioPool(), "IOWorker-" + storageKey.type()
         );
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RecreatingChunkStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/RecreatingChunkStorage.java
index 97ac637766cc2d870b404fdf398a6a052ae91f4a..9939d44f67d9fc67584db31e6889316eebb4bb6a 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RecreatingChunkStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RecreatingChunkStorage.java
@@ -13,11 +13,11 @@ public class RecreatingChunkStorage extends ChunkStorage {
     private final Path writeFolder;
 
     public RecreatingChunkStorage(
-        RegionStorageInfo storageKey, Path directory, RegionStorageInfo outputStorageKey, Path outputDirectory, DataFixer dataFixer, boolean dsync
+        org.stupidcraft.linearpaper.region.RegionFileFormat format, int linearCompression, RegionStorageInfo storageKey, Path directory, RegionStorageInfo outputStorageKey, Path outputDirectory, DataFixer dataFixer, boolean dsync
     ) {
-        super(storageKey, directory, dataFixer, dsync);
+        super(format, linearCompression, storageKey, directory, dataFixer, dsync);
         this.writeFolder = outputDirectory;
-        this.writeWorker = new IOWorker(outputStorageKey, outputDirectory, dsync);
+        this.writeWorker = new IOWorker(format, linearCompression, outputStorageKey, outputDirectory, dsync);
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RecreatingSimpleRegionStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/RecreatingSimpleRegionStorage.java
index 23adc60c8a066f9acde3c18c48629e07a1ec56a6..413556c9ac5659f9f46e7bd5433e6ed5abb308b6 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RecreatingSimpleRegionStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RecreatingSimpleRegionStorage.java
@@ -15,6 +15,10 @@ public class RecreatingSimpleRegionStorage extends SimpleRegionStorage {
     private final Path writeFolder;
 
     public RecreatingSimpleRegionStorage(
+        // LinearPaper start
+        org.stupidcraft.linearpaper.region.RegionFileFormat format,
+        int linearCompression,
+        // LinearPaper end
         RegionStorageInfo storageKey,
         Path directory,
         RegionStorageInfo outputStorageKey,
@@ -23,9 +27,9 @@ public class RecreatingSimpleRegionStorage extends SimpleRegionStorage {
         boolean dsync,
         DataFixTypes dataFixTypes
     ) {
-        super(storageKey, directory, dataFixer, dsync, dataFixTypes);
+        super(format, linearCompression, storageKey, directory, dataFixer, dsync, dataFixTypes);
         this.writeFolder = outputDirectory;
-        this.writeWorker = new IOWorker(outputStorageKey, outputDirectory, dsync);
+        this.writeWorker = new IOWorker(format, linearCompression, outputStorageKey, outputDirectory, dsync);
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
index 0d6f458d2830eadc0938c75a80666f9d3603cbee..99104c3bfb83b34014fcc11c4905ff7045ef145b 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
@@ -25,6 +25,10 @@ public class RegionFileStorage implements AutoCloseable {
     private final RegionStorageInfo info;
     private final Path folder;
     private final boolean sync;
+    // LinearPaper start
+    public final org.stupidcraft.linearpaper.region.RegionFileFormat format;
+    public final int linearCompression;
+    // LinearPaper end
     private final boolean isChunkData; // Paper
 
     // Paper start - cache regionfile does not exist state
@@ -56,11 +60,15 @@ public class RegionFileStorage implements AutoCloseable {
     }
     // Paper end - cache regionfile does not exist state
 
-    protected RegionFileStorage(RegionStorageInfo storageKey, Path directory, boolean dsync) { // Paper - protected constructor
+    protected RegionFileStorage(org.stupidcraft.linearpaper.region.RegionFileFormat format, int linearCompression, RegionStorageInfo storageKey, Path directory, boolean dsync) { // Paper - protected constructor // LinearPaper
         // Paper start - add isChunkData param
-        this(storageKey, directory, dsync, false);
+        this(format, linearCompression, storageKey, directory, dsync, false); // LinearPaper
     }
-    RegionFileStorage(RegionStorageInfo storageKey, Path directory, boolean dsync, boolean isChunkData) {
+    RegionFileStorage(org.stupidcraft.linearpaper.region.RegionFileFormat format, int linearCompression, RegionStorageInfo storageKey, Path directory, boolean dsync, boolean isChunkData) { // LinearPaper
+        // LinearPaper start
+        this.format = format;
+        this.linearCompression = linearCompression;
+        // LinearPaper end
         this.isChunkData = isChunkData;
         // Paper end - add isChunkData param
         this.folder = directory;
@@ -72,7 +80,7 @@ public class RegionFileStorage implements AutoCloseable {
     @Nullable
     public static ChunkPos getRegionFileCoordinates(Path file) {
         String fileName = file.getFileName().toString();
-        if (!fileName.startsWith("r.") || !fileName.endsWith(".mca")) {
+        if (!fileName.startsWith("r.") || !fileName.endsWith(".mca") || !fileName.endsWith(".linear")) { // LinearPaper
             return null;
         }
 
@@ -131,16 +139,29 @@ public class RegionFileStorage implements AutoCloseable {
             // Paper - only create directory if not existing only - moved down
             Path path = this.folder;
             int j = chunkcoordintpair.getRegionX();
-            Path path1 = path.resolve("r." + j + "." + chunkcoordintpair.getRegionZ() + ".mca"); // Paper - diff on change
-            if (existingOnly && !java.nio.file.Files.exists(path1)) { // Paper start - cache regionfile does not exist state
-                this.markNonExisting(regionPos);
-                return null; // CraftBukkit
+            // LinearPaper start
+            Path path1;
+            if (existingOnly) {
+                Path anvil = path.resolve("r." + j + "." + chunkcoordintpair.getRegionZ() + ".mca");
+                Path linear = path.resolve("r." + j + "." + chunkcoordintpair.getRegionZ() + ".linear");
+                if (java.nio.file.Files.exists(anvil)) path1 = anvil;
+                else if (java.nio.file.Files.exists(linear)) path1 = linear;
+                else {
+                    this.markNonExisting(regionPos);
+                    return null;
+                }
             } else {
+                String extension = switch (this.format) {
+                    case LINEAR -> "linear";
+                    default -> "mca";
+                };
+                path1 = path.resolve("r." + j + "." + chunkcoordintpair.getRegionZ() + "." + extension);
+                // LinearPaper end
                 this.createRegionFile(regionPos);
             }
             // Paper end - cache regionfile does not exist state
             FileUtil.createDirectoriesSafe(this.folder); // Paper - only create directory if not existing only - moved from above
-            org.stupidcraft.linearpaper.region.AbstractRegionFile regionfile1 = org.stupidcraft.linearpaper.region.AbstractRegionFileFactory.getAbstractRegionFile(this.info, path1, this.folder, this.sync, this.isChunkData); // Paper - allow for chunk regionfiles to regen header // LinearPaper
+            org.stupidcraft.linearpaper.region.AbstractRegionFile regionfile1 = org.stupidcraft.linearpaper.region.AbstractRegionFileFactory.getAbstractRegionFile(this.linearCompression, this.info, path1, this.folder, this.sync, this.isChunkData); // Paper - allow for chunk regionfiles to regen header // LinearPaper
 
             this.regionCache.putAndMoveToFirst(i, regionfile1);
             // Paper start
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/SectionStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/SectionStorage.java
index a4a919d8373f1535e336de7e648d41a07efb1cba..ddea645cd3a29fa1d8105d0d2d919b6508ce855d 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/SectionStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/SectionStorage.java
@@ -44,6 +44,10 @@ public class SectionStorage<R> extends RegionFileStorage implements AutoCloseabl
     protected final LevelHeightAccessor levelHeightAccessor;
 
     public SectionStorage(
+        // LinearPaper start
+        org.stupidcraft.linearpaper.region.RegionFileFormat format,
+        int linearCompression,
+        // LinearPaper end
         // Paper start
         RegionStorageInfo regionStorageInfo,
         Path path,
@@ -55,7 +59,7 @@ public class SectionStorage<R> extends RegionFileStorage implements AutoCloseabl
         RegistryAccess registryManager,
         LevelHeightAccessor world
     ) {
-        super(regionStorageInfo, path, dsync); // Paper - remove mojang I/O thread
+        super(format, linearCompression, regionStorageInfo, path, dsync); // Paper - remove mojang I/O thread // LinearPaper
         this.codec = codecFactory;
         this.factory = factory;
         this.registryAccess = registryManager;
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/SimpleRegionStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/SimpleRegionStorage.java
index fa4f9afb421c7924557372cbb2f20caf9e13c81c..8a3492b5d2c291ffb5bb8de5e3bca71cc026f0e0 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/SimpleRegionStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/SimpleRegionStorage.java
@@ -18,10 +18,10 @@ public class SimpleRegionStorage implements AutoCloseable {
     private final DataFixer fixerUpper;
     private final DataFixTypes dataFixType;
 
-    public SimpleRegionStorage(RegionStorageInfo storageKey, Path directory, DataFixer dataFixer, boolean dsync, DataFixTypes dataFixTypes) {
+    public SimpleRegionStorage(org.stupidcraft.linearpaper.region.RegionFileFormat format, int linearCompression, RegionStorageInfo storageKey, Path directory, DataFixer dataFixer, boolean dsync, DataFixTypes dataFixTypes) {
         this.fixerUpper = dataFixer;
         this.dataFixType = dataFixTypes;
-        this.worker = new IOWorker(storageKey, directory, dsync);
+        this.worker = new IOWorker(format, linearCompression, storageKey, directory, dsync);
     }
 
     public CompletableFuture<Optional<CompoundTag>> read(ChunkPos pos) {
diff --git a/src/main/java/org/stupidcraft/linearpaper/region/AbstractRegionFileFactory.java b/src/main/java/org/stupidcraft/linearpaper/region/AbstractRegionFileFactory.java
index a2ac8e822564ce0bc903c902aa5566afdc400314..935305bd84d5280db39e10ba4fa88bea914beaa3 100644
--- a/src/main/java/org/stupidcraft/linearpaper/region/AbstractRegionFileFactory.java
+++ b/src/main/java/org/stupidcraft/linearpaper/region/AbstractRegionFileFactory.java
@@ -7,19 +7,23 @@ import net.minecraft.world.level.chunk.storage.RegionFileVersion;
 import net.minecraft.world.level.chunk.storage.RegionStorageInfo;
 
 public class AbstractRegionFileFactory {
-    public static AbstractRegionFile getAbstractRegionFile(RegionStorageInfo storageKey, Path directory, Path path, boolean dsync) throws IOException {
-        return getAbstractRegionFile(storageKey, directory, path, RegionFileVersion.getCompressionFormat(), dsync);
+    public static AbstractRegionFile getAbstractRegionFile(int linearCompression, RegionStorageInfo storageKey, Path directory, Path path, boolean dsync) throws IOException {
+        return getAbstractRegionFile(linearCompression, storageKey, directory, path, RegionFileVersion.getCompressionFormat(), dsync);
     }
 
-    public static AbstractRegionFile getAbstractRegionFile(RegionStorageInfo storageKey, Path directory, Path path, boolean dsync, boolean canRecalcHeader) throws IOException {
-        return getAbstractRegionFile(storageKey, directory, path, RegionFileVersion.getCompressionFormat(), dsync, canRecalcHeader);
+    public static AbstractRegionFile getAbstractRegionFile(int linearCompression, RegionStorageInfo storageKey, Path directory, Path path, boolean dsync, boolean canRecalcHeader) throws IOException {
+        return getAbstractRegionFile(linearCompression, storageKey, directory, path, RegionFileVersion.getCompressionFormat(), dsync, canRecalcHeader);
     }
 
-    public static AbstractRegionFile getAbstractRegionFile(RegionStorageInfo storageKey, Path path, Path directory, RegionFileVersion compressionFormat, boolean dsync) throws IOException {
-        return getAbstractRegionFile(storageKey, path, directory, compressionFormat, dsync, true);
+    public static AbstractRegionFile getAbstractRegionFile(int linearCompression, RegionStorageInfo storageKey, Path path, Path directory, RegionFileVersion compressionFormat, boolean dsync) throws IOException {
+        return getAbstractRegionFile(linearCompression, storageKey, path, directory, compressionFormat, dsync, true);
     }
 
-    public static AbstractRegionFile getAbstractRegionFile(RegionStorageInfo storageKey, Path path, Path directory, RegionFileVersion compressionFormat, boolean dsync, boolean canRecalcHeader) throws IOException {
-        return new RegionFile(storageKey, path, directory, compressionFormat, dsync, canRecalcHeader);
+    public static AbstractRegionFile getAbstractRegionFile(int linearCompression, RegionStorageInfo storageKey, Path path, Path directory, RegionFileVersion compressionFormat, boolean dsync, boolean canRecalcHeader) throws IOException {
+        if (path.toString().endsWith(".linear")) {
+            return new LinearRegionFile(path, linearCompression);
+        } else {
+            return new RegionFile(storageKey, path, directory, compressionFormat, dsync, canRecalcHeader);
+        }
     }
 }
diff --git a/src/main/java/org/stupidcraft/linearpaper/region/LinearRegionFile.java b/src/main/java/org/stupidcraft/linearpaper/region/LinearRegionFile.java
new file mode 100644
index 0000000000000000000000000000000000000000..6df6847721003c18647f8dc8d4e4b10d537bce0c
--- /dev/null
+++ b/src/main/java/org/stupidcraft/linearpaper/region/LinearRegionFile.java
@@ -0,0 +1,319 @@
+package org.stupidcraft.linearpaper.region;
+
+import com.github.luben.zstd.ZstdInputStream;
+import com.github.luben.zstd.ZstdOutputStream;
+import com.mojang.logging.LogUtils;
+import java.io.BufferedOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.StandardCopyOption;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.ReentrantLock;
+import javax.annotation.Nullable;
+import net.jpountz.lz4.LZ4Compressor;
+import net.jpountz.lz4.LZ4Factory;
+import net.jpountz.lz4.LZ4FastDecompressor;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.status.ChunkStatus;
+import org.slf4j.Logger;
+
+public class LinearRegionFile implements AbstractRegionFile, AutoCloseable {
+    private static final long SUPERBLOCK = -4323716122432332390L;
+    private static final byte VERSION = 2;
+    private static final int HEADER_SIZE = 32;
+    private static final int FOOTER_SIZE = 8;
+    private static final Logger LOGGER = LogUtils.getLogger();
+    private static final List<Byte> SUPPORTED_VERSIONS = Arrays.asList((byte) 1, (byte) 2);
+    private static final LinearRegionFileFlusher linearRegionFileFlusher = new LinearRegionFileFlusher();
+    public final ReentrantLock fileLock = new ReentrantLock(true);
+    private final byte[][] buffer = new byte[1024][];
+    private final int[] bufferUncompressedSize = new int[1024];
+    private final int[] chunkTimestamps = new int[1024];
+    private final ChunkStatus[] statuses = new ChunkStatus[1024];
+    private final LZ4Compressor compressor;
+    private final LZ4FastDecompressor decompressor;
+    private final int compressionLevel;
+    public boolean closed = false;
+    public Path path;
+    private final AtomicBoolean markedToSave = new AtomicBoolean(false);
+
+
+    public LinearRegionFile(Path file, int compression) throws IOException {
+        this.path = file;
+        this.compressionLevel = compression;
+        this.compressor = LZ4Factory.fastestInstance().fastCompressor();
+        this.decompressor = LZ4Factory.fastestInstance().fastDecompressor();
+
+        File regionFile = new File(this.path.toString());
+
+        Arrays.fill(this.bufferUncompressedSize, 0);
+
+        if (!regionFile.canRead()) return;
+
+        try (FileInputStream fileStream = new FileInputStream(regionFile);
+             DataInputStream rawDataStream = new DataInputStream(fileStream)) {
+
+            long superBlock = rawDataStream.readLong();
+            if (superBlock != SUPERBLOCK)
+                throw new RuntimeException("Invalid superblock: " + superBlock + " in " + file);
+
+            byte version = rawDataStream.readByte();
+            if (!SUPPORTED_VERSIONS.contains(version))
+                throw new RuntimeException("Invalid version: " + version + " in " + file);
+
+            // Skip newestTimestamp (Long) + Compression level (Byte) + Chunk count (Short): Unused.
+            rawDataStream.skipBytes(11);
+
+            int dataCount = rawDataStream.readInt();
+            long fileLength = file.toFile().length();
+            if (fileLength != HEADER_SIZE + dataCount + FOOTER_SIZE)
+                throw new IOException("Invalid file length: " + this.path + " " + fileLength + " " + (HEADER_SIZE + dataCount + FOOTER_SIZE));
+
+            rawDataStream.skipBytes(8); // Skip data hash (Long): Unused.
+
+            byte[] rawCompressed = new byte[dataCount];
+            rawDataStream.readFully(rawCompressed, 0, dataCount);
+
+            superBlock = rawDataStream.readLong();
+            if (superBlock != SUPERBLOCK)
+                throw new IOException("Footer superblock invalid " + this.path);
+
+            try (DataInputStream dataStream = new DataInputStream(new ZstdInputStream(new ByteArrayInputStream(rawCompressed)))) {
+
+                int[] starts = new int[1024];
+                for (int i = 0; i < 1024; i++) {
+                    starts[i] = dataStream.readInt();
+                    dataStream.skipBytes(4); // Skip timestamps (Int): Unused.
+                }
+
+                for (int i = 0; i < 1024; i++) {
+                    if (starts[i] > 0) {
+                        int size = starts[i];
+                        byte[] b = new byte[size];
+                        dataStream.readFully(b, 0, size);
+
+                        int maxCompressedLength = this.compressor.maxCompressedLength(size);
+                        byte[] compressed = new byte[maxCompressedLength];
+                        int compressedLength = this.compressor.compress(b, 0, size, compressed, 0, maxCompressedLength);
+                        b = new byte[compressedLength];
+                        System.arraycopy(compressed, 0, b, 0, compressedLength);
+
+                        this.buffer[i] = b;
+                        this.bufferUncompressedSize[i] = size;
+                    }
+                }
+            }
+        }
+    }
+
+    private static int getChunkIndex(int x, int z) {
+        return (x & 31) + ((z & 31) << 5);
+    }
+
+    private static int getTimestamp() {
+        return (int) (System.currentTimeMillis() / 1000L);
+    }
+
+    public Path getRegionFile() {
+        return this.path;
+    }
+
+    public ReentrantLock getFileLock() {
+        return this.fileLock;
+    }
+
+    public void flush() throws IOException {
+        if (isMarkedToSave()) flushWrapper(); // sync
+    }
+
+    private void markToSave() {
+        linearRegionFileFlusher.scheduleSave(this);
+        markedToSave.set(true);
+    }
+
+    public boolean isMarkedToSave() {
+        return markedToSave.getAndSet(false);
+    }
+
+    public void flushWrapper() {
+        try {
+            save();
+        } catch (IOException e) {
+            LOGGER.error("Failed to flush region file " + path.toAbsolutePath(), e);
+        }
+    }
+
+    public boolean doesChunkExist(ChunkPos pos) throws Exception {
+        throw new Exception("doesChunkExist is a stub");
+    }
+
+    private synchronized void save() throws IOException {
+        long timestamp = getTimestamp();
+        short chunkCount = 0;
+
+        File tempFile = new File(path.toString() + ".tmp");
+
+        try (FileOutputStream fileStream = new FileOutputStream(tempFile);
+             ByteArrayOutputStream zstdByteArray = new ByteArrayOutputStream();
+             ZstdOutputStream zstdStream = new ZstdOutputStream(zstdByteArray, this.compressionLevel);
+             DataOutputStream zstdDataStream = new DataOutputStream(zstdStream);
+             DataOutputStream dataStream = new DataOutputStream(fileStream)) {
+
+            dataStream.writeLong(SUPERBLOCK);
+            dataStream.writeByte(VERSION);
+            dataStream.writeLong(timestamp);
+            dataStream.writeByte(this.compressionLevel);
+
+            ArrayList<byte[]> byteBuffers = new ArrayList<>();
+            for (int i = 0; i < 1024; i++) {
+                if (this.bufferUncompressedSize[i] != 0) {
+                    chunkCount += 1;
+                    byte[] content = new byte[bufferUncompressedSize[i]];
+                    this.decompressor.decompress(buffer[i], 0, content, 0, bufferUncompressedSize[i]);
+
+                    byteBuffers.add(content);
+                } else byteBuffers.add(null);
+            }
+            for (int i = 0; i < 1024; i++) {
+                zstdDataStream.writeInt(this.bufferUncompressedSize[i]); // Write uncompressed size
+                zstdDataStream.writeInt(this.chunkTimestamps[i]); // Write timestamp
+            }
+            for (int i = 0; i < 1024; i++) {
+                if (byteBuffers.get(i) != null)
+                    zstdDataStream.write(byteBuffers.get(i), 0, byteBuffers.get(i).length);
+            }
+            zstdDataStream.close();
+
+            dataStream.writeShort(chunkCount);
+
+            byte[] compressed = zstdByteArray.toByteArray();
+
+            dataStream.writeInt(compressed.length);
+            dataStream.writeLong(0);
+
+            dataStream.write(compressed, 0, compressed.length);
+            dataStream.writeLong(SUPERBLOCK);
+
+            dataStream.flush();
+            fileStream.getFD().sync();
+            fileStream.getChannel().force(true); // Ensure atomicity on Btrfs
+        }
+        Files.move(tempFile.toPath(), this.path, StandardCopyOption.REPLACE_EXISTING);
+    }
+
+    public void setStatus(int x, int z, ChunkStatus status) {
+        this.statuses[getChunkIndex(x, z)] = status;
+    }
+
+    public synchronized void write(ChunkPos pos, ByteBuffer buffer) {
+        try {
+            byte[] b = toByteArray(new ByteArrayInputStream(buffer.array()));
+            int uncompressedSize = b.length;
+
+            int maxCompressedLength = this.compressor.maxCompressedLength(b.length);
+            byte[] compressed = new byte[maxCompressedLength];
+            int compressedLength = this.compressor.compress(b, 0, b.length, compressed, 0, maxCompressedLength);
+            b = new byte[compressedLength];
+            System.arraycopy(compressed, 0, b, 0, compressedLength);
+
+            int index = getChunkIndex(pos.x, pos.z);
+            this.buffer[index] = b;
+            this.chunkTimestamps[index] = getTimestamp();
+            this.bufferUncompressedSize[getChunkIndex(pos.x, pos.z)] = uncompressedSize;
+        } catch (IOException e) {
+            LOGGER.error("Chunk write IOException " + e + " " + this.path);
+        }
+        markToSave();
+    }
+
+    public DataOutputStream getChunkDataOutputStream(ChunkPos pos) {
+        return new DataOutputStream(new BufferedOutputStream(new ChunkBuffer(pos)));
+    }
+
+    private byte[] toByteArray(InputStream in) throws IOException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        byte[] tempBuffer = new byte[4096];
+
+        int length;
+        while ((length = in.read(tempBuffer)) >= 0) {
+            out.write(tempBuffer, 0, length);
+        }
+
+        return out.toByteArray();
+    }
+
+    @Nullable
+    public synchronized DataInputStream getChunkDataInputStream(ChunkPos pos) {
+        if (this.bufferUncompressedSize[getChunkIndex(pos.x, pos.z)] != 0) {
+            byte[] content = new byte[bufferUncompressedSize[getChunkIndex(pos.x, pos.z)]];
+            this.decompressor.decompress(this.buffer[getChunkIndex(pos.x, pos.z)], 0, content, 0, bufferUncompressedSize[getChunkIndex(pos.x, pos.z)]);
+            return new DataInputStream(new ByteArrayInputStream(content));
+        }
+        return null;
+    }
+
+    public ChunkStatus getStatusIfCached(int x, int z) {
+        return this.statuses[getChunkIndex(x, z)];
+    }
+
+    public void clear(ChunkPos pos) {
+        int i = getChunkIndex(pos.x, pos.z);
+        this.buffer[i] = null;
+        this.bufferUncompressedSize[i] = 0;
+        this.chunkTimestamps[i] = getTimestamp();
+        markToSave();
+    }
+
+    public boolean hasChunk(ChunkPos pos) {
+        return this.bufferUncompressedSize[getChunkIndex(pos.x, pos.z)] > 0;
+    }
+
+    public void close() throws IOException {
+        if (closed) return;
+        closed = true;
+        flush(); // sync
+    }
+
+    public boolean recalculateHeader() {
+        return false;
+    }
+
+    public void setOversized(int x, int z, boolean something) {
+    }
+
+    public CompoundTag getOversizedData(int x, int z) throws IOException {
+        throw new IOException("getOversizedData is a stub " + this.path);
+    }
+
+    public boolean isOversized(int x, int z) {
+        return false;
+    }
+
+    private class ChunkBuffer extends ByteArrayOutputStream {
+        private final ChunkPos pos;
+
+        public ChunkBuffer(ChunkPos chunkcoordintpair) {
+            super();
+            this.pos = chunkcoordintpair;
+        }
+
+        public void close() throws IOException {
+            ByteBuffer bytebuffer = ByteBuffer.wrap(this.buf, 0, this.count);
+            LinearRegionFile.this.write(this.pos, bytebuffer);
+        }
+    }
+}
diff --git a/src/main/java/org/stupidcraft/linearpaper/region/LinearRegionFileFlusher.java b/src/main/java/org/stupidcraft/linearpaper/region/LinearRegionFileFlusher.java
new file mode 100644
index 0000000000000000000000000000000000000000..d6685a6854de3f9391cca5a6435fd103cc22029d
--- /dev/null
+++ b/src/main/java/org/stupidcraft/linearpaper/region/LinearRegionFileFlusher.java
@@ -0,0 +1,49 @@
+package org.stupidcraft.linearpaper.region;
+
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import io.papermc.paper.configuration.GlobalConfiguration;
+import java.util.Queue;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import org.bukkit.Bukkit;
+
+public class LinearRegionFileFlusher {
+    private final Queue<LinearRegionFile> savingQueue = new LinkedBlockingQueue<>();
+    private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor(
+        new ThreadFactoryBuilder()
+            .setNameFormat("linear-flush-scheduler")
+            .build()
+    );
+    private final ExecutorService executor = Executors.newFixedThreadPool(
+        GlobalConfiguration.get().regionFormat.linearFlushThreads,
+        new ThreadFactoryBuilder()
+            .setNameFormat("linear-flusher-%d")
+            .build()
+    );
+
+    public LinearRegionFileFlusher() {
+        Bukkit.getLogger().info("Using " + GlobalConfiguration.get().regionFormat.linearFlushThreads + " threads for linear region flushing.");
+        scheduler.scheduleAtFixedRate(this::pollAndFlush, 0L, GlobalConfiguration.get().regionFormat.linearFlushFrequency, TimeUnit.SECONDS);
+    }
+
+    public void scheduleSave(LinearRegionFile regionFile) {
+        if (savingQueue.contains(regionFile)) return;
+        savingQueue.add(regionFile);
+    }
+
+    private void pollAndFlush() {
+        while (!savingQueue.isEmpty()) {
+            LinearRegionFile regionFile = savingQueue.poll();
+            if (!regionFile.closed && regionFile.isMarkedToSave())
+                executor.execute(regionFile::flushWrapper);
+        }
+    }
+
+    public void shutdown() {
+        executor.shutdown();
+        scheduler.shutdown();
+    }
+}
